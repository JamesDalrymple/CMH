setkey(insure, primary_ins)[J(modify$not_ins), primary_ins := NA]
setkey(insure, secondary_ins)[J(modify$not_ins), secondary_ins := NA]
setkey(insure, other_ins)[J(modify$not_ins), other_ins := NA]
# remove COFR consumers from results per Kelly B 11/4/2015
modify$cofr_cases <-
unique(insure[grep(x = primary_ins, pattern = "COFR"), case_no],
insure[grep(x = secondary_ins, pattern = "COFR"), case_no],
insure[grep(x = other_ins, pattern = "COFR"), case_no])
# insure[case_no %in% modify$cofr_cases,
# .SD, .SDc = c("case_no", "primary_ins")]
## Medicare HMO ##
# set medicare="Y" if consumer has HMO Medicare
insure[grep(x = primary_ins, pattern = "medicare", ignore.case = TRUE),
medicare := "Y"]
insure[grep(x = secondary_ins, pattern = "medicare",
ignore.case = TRUE), medicare := "Y"]
invisible(insure[grep(x = other_ins, pattern = "medicare",
ignore.case = TRUE), medicare := "Y"])
# remove medicare HMO from private insurance
insure[grep(x = primary_ins, pattern = "medicare", ignore.case = TRUE),
primary_ins := NA]
insure[grep(x = secondary_ins, pattern = "medicare",
ignore.case = TRUE), secondary_ins := NA]
invisible(insure[grep(x = other_ins, pattern = "medicare", ignore.case =
TRUE), other_ins := NA])
## make primary insurance column ##
insure[!is.na(primary_ins) | !is.na(secondary_ins) |
!is.na(other_ins), private_insurance := "Y"]
insure[is.na(primary_ins) & is.na(secondary_ins) & is.na(other_ins),
private_insurance := "N"]
# remove duplicates
insure <- unique(insure)
### make fund columns ###
# add MI Child to Medicaid
setkey(insure, medicaid)[J(c("Medicaid", "MI Child")), fund := "Medicaid"]
# spend-down
setkey(insure, medicaid)[J(c("S/D/N", "S/D/Y")), fund := "spend-down"]
invisible(setkey(insure, NULL))
insure[fund == "spend-down" &
waiver == "HAB Waiver", fund := "HAB spend-down"]
# per Kelly B on 9/25/2015
insure[is.na(fund) & waiver == "HAB Waiver", fund := "Medicaid"]
# insure[, table(waiver, medicaid)] #### checking ...
# HMP
insure[medicaid == "HMP", fund := "HMP"]
# grouping Medicare and private ins. together
insure[is.na(fund) &
(medicare == "Y" | private_insurance == "Y"),
fund := "Medicare/TPP"]
# GF consumers because they have no insurance (as far as we know)
insure[is.na(fund), fund := "GF"]
# remove medicaid columns
# insure[, c("medicaid", "waiver") := NULL]
# get rid of case_no NAs
insure <- insure[!is.na(case_no)]
### ins_detail ###
# ins_detail <- unique(ins_detail)
ins_detail <-
setkey(ins_detail, insurance_name)[!J(modify$not_ins)]
ins_detail <-
ins_detail[!grep(x = insurance_name, pattern = "COFR")]
ins_detail <-
ins_detail[!grep(x = insurance_name, pattern = "Medicare", ignore.case =
TRUE)]
add_private_ins <- merge(insure, ins_detail, all.y = TRUE,
by = "case_no")[!is.na(private_insurance)][private_insurance == "N"]
setkey(insure, case_no)[J(add_private_ins[,
unique(case_no)]), private_insurance := "Y"]
rm(add_private_ins, ins_detail)
### locus ###
# convert dates
date_cols = c("adm_date", "locus_date")
for (j in date_cols)
set(locus, j = j, value = as.Date(locus[[j]]))
rm(date_cols, j)
# locus disposition level
locus[is.na(override), disp := recommend]
locus[!is.na(override), disp := override]
# find recent admissions (last 6 months)
locus[, days_cmh_open := date_convert(input$end_date) - adm_date]
locus[between(days_cmh_open,-Inf, 182), open_status := "0 to 6 months"]
locus[between(days_cmh_open, 183, 364), open_status := "6 to 12 months"]
locus[, adm_diff := as.numeric(adm_date - locus_date)]
locus[, min_adm_diff := min(adm_diff), by = list(case_no)]
locus <- locus[min_adm_diff == adm_diff]
# remove unwanted columns
locus[, c("adm_diff", "min_adm_diff", "recommend",
"override", "adm_date") := NULL]
locus <- locus[!is.na(open_status)]
locus[, disp := trim(disp)]
locus[, disp := sapply(disp, aux$word_to_num)]
# cmh crisis ------------------------------------------------------------------
setnames(cmh_crisis, names(cmh_crisis), tolower(names(cmh_crisis)))
setnames(
cmh_crisis,
old = c("cpt_code", "medicaid_related"),
new = c("cpt", "medicaid")
)
# CRS is not a CMH team ... have Snow fix this
cmh_crisis <- cmh_crisis[!team=="Crisis Residential Services"]
cmh_crisis[, team := wccmh::cmh_recode(team)]
cmh_crisis[, program := wccmh::recode_team_prog(team)]
cmh_crisis[fb_unit_type, unit_type := unit_type,
on = c(cpt = "cpt", cpt_modifier = "mod")]
cmh_crisis[fb_unit_type, unit_type := unit_type,
on = c(cpt = "cpt", cpt_modifier = "mod")]
cmh_crisis[is.na(unit_type), unit_type := "missing"]
cmh_crisis[um_code_desc, cpt_desc := UM.Desc, on = c(cpt = "CPT.CD")]
modify$TCM_cmh <- cmh_crisis[cpt == "T1017" & program =="MI",
list(TCM = length(cpt)), by = case_no]
locus <- merge(locus, modify$TCM_cmh, all.x = TRUE, by = "case_no")
locus[is.na(TCM), TCM := 0]
### create prediction disposition ###
# consumers open less than 6 months
# locus[, pred_level := NA_integer_]
locus[open_status == "0 to 6 months", pred_level := disp]
locus[open_status == "6 to 12 months",
pred_TCM := 365 * TCM / as.integer(days_cmh_open)]
locus[open_status == "6 to 12 months",
pred_TCM_level := aux$levelTCM(pred_TCM)]
locus[open_status == "6 to 12 months",
pred_model := as.integer(days_cmh_open - 182) / 182 * pred_TCM_level +
(182 - as.integer(days_cmh_open - 182)) / 182 * disp]
locus[open_status == "6 to 12 months",
pred_round := pmin(round(pred_model), 3)]
locus[, replace_level := ifelse(!is.na(pred_round), pred_round, pred_level)]
locus[, setdiff(names(locus), c("case_no", "replace_level")) := NULL]
# non_cmh_crisis --------------------------------------------------------------
setnames(
non_cmh_crisis,
old = c("cpt_code", "medicaid_related", "team2"),
new = c("cpt", "medicaid", "team")
)
non_cmh_crisis[fb_unit_type, unit_type := unit_type,
on = c(cpt = "cpt", cpt_modifier = "mod")]
non_cmh_crisis[is.na(unit_type), unit_type := "missing"]
non_cmh_crisis[um_code_desc, cpt_desc := UM.Desc, on = c(cpt = "CPT.CD")]
#### aggregate data ####
x <- copy(non_cmh_crisis)
# add fb cost
x[fb_cpt_mod_cost,
cost := units * i.unit_cost,
on = c("cpt" = "PRI PROCEDURE CODE", "cpt_modifier" = "MOD")]
# summarize based on unit_type
services <- rbindlist(list(x[!(unit_type %in% c("Day", "Encounter")),
list(records = length(service_date),
units = sum(units, na.rm = TRUE),
cost = sum(cost, na.rm = TRUE)),
by = list(case_no, team, cpt, cpt_desc,
unit_type)],
x[unit_type %in% c("Day", "Encounter"),
list(records = sum(units, na.rm = TRUE),
units = sum(units, na.rm = TRUE),
cost = sum(cost, na.rm = TRUE)),
by = list(case_no, team, cpt, cpt_desc,
unit_type)]))
6*8.5+13+5*5
services
services[, unique(cost)]
services[cost==Inf]
x[case_no==1136878]
x[case_no==1136878, cost]
x[case_no==1136878 & cost==Inf]
fb_cpt_mod_cost[1]
fb_cpt_mod_cost[`PRI PROCEDURE CODE`=="H2015"]
fb_cpt_mod_cost[`PRI PROCEDURE CODE`=="T2038"]
sql$fb_full_list <-
list.files(path = "G:/CSTS Data Analyst Archives/FB_archives/rds",
full.names = TRUE)
read_these_fb <-
grep(x=sql$fb_full_list,
pattern="8_31_14_to_8_31_15 ran 11_03_15", value = TRUE)
fb_data <-
Reduce(
f = function(...)
rbindlist(list(...), use.names = TRUE),
x = lapply(read_these_fb, readRDS)
)
require(data.table)
sql$fb_full_list <-
list.files(path = "G:/CSTS Data Analyst Archives/FB_archives/rds",
full.names = TRUE)
read_these_fb <-
grep(x=sql$fb_full_list,
pattern="8_31_14_to_8_31_15 ran 11_03_15", value = TRUE)
fb_data <-
Reduce(
f = function(...)
rbindlist(list(...), use.names = TRUE),
x = lapply(read_these_fb, readRDS)
)
setnames(fb_data, c("PRI PROCEDURE CODE", "MOD", "ALLOWED AMOUNT", "UNITS"),
"cpt", "mod", "cost", "units")
setnames(fb_data, c("PRI PROCEDURE CODE", "MOD", "ALLOWED AMOUNT", "UNITS"),
c("cpt", "mod", "cost", "units"))
fb_data
fb_data[, # unit_cost :=
round(mean(cost/units, na.rm = TRUE), 2),
by = list(cpt, mod)]
round(mean(cost/units, na.rm = TRUE), 2),
fb_data[, # unit_cost :=
round(mean(cost/units, na.rm = TRUE), 2),
by = list(cpt, mod)][, max(V1)]
fb_data[, unique(cost)]
fb_data[, EquaPac::stunq(cost)]
fb_data[, EquaPac::stunq(units)]
2/0
fb2 <- fb_data[, list(units = sum(units, na.rm = TRUE),
cost = sum(cost, na.rm = TRUE)),
by = list(cpt, mod)]
fb2
fb2[, min(units)]
fb2[, max(units)]
fb2[, max(cost)]
fb2[, min(cost)]
fb2[mod == "  ", mod := NA_character_]
fb2
fb2[, unit_cost :=
round(mean(cost/units, na.rm = TRUE), 2),
by = list(cpt, mod)]
fb2[, max(unit_cost)]
fb2[, min(unit_cost)]
fb2[unit_cost==max(unit_cost)]
save(fb2, file = "C:/Users/dalrymplej/Documents/GitHub/wccmh/datafb_unit_cost_by_cpt_mod.rda")
save(fb2, file = "C:/Users/dalrymplej/Documents/GitHub/wccmh/data/fb_unit_cost_by_cpt_mod.rda")
source(file.path(project_wd$code, "crisis services/3_export_xlsx.R"))
# initializing working directory and input parameters -------------------------
rm(list = ls()) # clear RAM
# which computer results in correct base working directory
cmh_wd <-
data.table::data.table(expand.grid(stringsAsFactors = FALSE,
dir_names = c("Dropbox", "GitHub"),
comp_names = c("WSHSQLGP", "DESKTOP-45K7RRN", "JAMES-2"),
base = "filler"))
data.table::setkey(cmh_wd, dir_names, comp_names)[
J("Dropbox", "WSHSQLGP"), base := "C:/Users/dalrymplej/Dropbox"]
data.table::setkey(cmh_wd, dir_names, comp_names)[
J("GitHub", "WSHSQLGP"), base := "C:/Users/dalrymplej/Documents/GitHub"]
project_wd <- list()
project_wd$github <- cmh_wd[J("GitHub", "WSHSQLGP"), base]
project_wd$dropbox <- cmh_wd[J("Dropbox", "WSHSQLGP"), base]
project_wd$project <- "CMH/UM/Fund"
project_wd$sub_folder <- "crisis services"
project_wd$code <- file.path(project_wd$github, project_wd$project, "Code")
project_wd$data <- file.path(project_wd$dropbox,
"Utilization Management/Fund Only/Data")
project_wd$results <- "Utilization Management/Fund Only/Results"
rm(cmh_wd)
# user input ------------------------------------------------------------------
input <- list(
run_date = Sys.Date(),
end_date = "8/31/2015"
)
# for folder
project_wd$data <- file.path(project_wd$data,
gsub(
x = input$run_date,
pattern = "/",
replace = "_"))
# load packages, source files -------------------------------------------------
library(wccmh)
source(file.path(project_wd$code, "0_service auxillary.R"))
source(file.path(project_wd$code, "crisis services/1_crisis_sql.R"))
source(file.path(project_wd$code, "crisis services/2_base_crisis.R"))
source(file.path(project_wd$code, "crisis services/3_export_xlsx.R"))
# initializing working directory and input parameters -------------------------
rm(list = ls()) # clear RAM
# which computer results in correct base working directory
cmh_wd <-
data.table::data.table(expand.grid(
stringsAsFactors = FALSE,
dir_names = c("Dropbox", "GitHub"),
comp_names = c("WSHSQLGP", "DESKTOP-45K7RRN", "JAMES-2"),
base = "filler"
))
data.table::setkey(cmh_wd, dir_names, comp_names)[J("Dropbox", "WSHSQLGP"), base := "C:/Users/dalrymplej/Dropbox"]
data.table::setkey(cmh_wd, dir_names, comp_names)[J("GitHub", "WSHSQLGP"), base := "C:/Users/dalrymplej/Documents/GitHub"]
project_wd <- list()
project_wd$github <- cmh_wd[J("GitHub", "WSHSQLGP"), base]
project_wd$dropbox <- cmh_wd[J("Dropbox", "WSHSQLGP"), base]
project_wd$project <- "CMH/UM/Fund"
project_wd$sub_folder <- "crisis services"
project_wd$code <-
file.path(project_wd$github, project_wd$project, "Code")
project_wd$data <- file.path(project_wd$dropbox,
"Utilization Management/Fund Only/Data")
project_wd$results <- "Utilization Management/Fund Only/Results"
rm(cmh_wd)
# user input ------------------------------------------------------------------
input <- list(
run_date = Sys.Date(),
end_date = "8/31/2015"
)
# for folder
project_wd$data <- file.path(project_wd$data,
gsub(
x = input$run_date,
pattern = "/",
replace = "_"))
# load packages, source files -------------------------------------------------
library(wccmh)
source(file.path(project_wd$code, "0_service auxillary.R"))
source(file.path(project_wd$code, "crisis services/1_crisis_sql.R"))
modify <- new.env(parent = .GlobalEnv)
#### Load Data ####
# current state hospital consumers
modify$state_hosp <- sql$state_hosp
cmh_crisis <- sql$cmh_crisis
# ------------- fixing data problem
non_cmh_crisis <- sql$non_cmh_crisis
# fix duplicate teams per consumer issue ... ask Snow why this happened
modify$non_cmh_priority_dt<-
data.table(team = c("WSH - PATH/PORT", "WSH - OBRA", "WSH - MH Court",
"WSH - Sobriety Court", NA),
priority = 1:5)
non_cmh_crisis[modify$non_cmh_priority_dt, priority := priority,
on = c(team2 = "team")]
non_cmh_crisis[, min_priority := min(priority), by = "case_no"]
non_cmh_crisis[modify$non_cmh_priority_dt, team2 := i.team,
on = c(min_priority = "priority")]
# non_cmh_crisis[case_no == 1137717] # duplicate teams for this consumer
non_cmh_crisis[, c("min_priority", "priority") := NULL]
# ----------------------- data issue fixed #
insure <- sql$insure
# case load
case_load <- sql$case_load
ins_detail <- sql$pvt_insure
locus <- sql$locus
setnames(locus,
old = c("recommended_disposition", "overidden_disposition",
"cmh_adm_date"),
new = c("recommend", "override", "adm_date"))
# #### manipulate data ####
# ### demographics data - contains primary care doctor ###
# demo <- unique(demo)
# ### court data ###
# court[, cs_order_date := as.Date(cs_order_date)]
# modify$levels <- court[, rev(unique(ordertype))]
# court[, ordertype := factor(ordertype, levels = modify$levels)]
# court <- court[order(case_no, ordertype)]
# court[, group := .GRP, by = list(case_no)]
# court[, index := .N, by = group]
# court <- court[!(index > 1 & ordertype == "Other")]
# court[, index := .N, by = group]
# court[, max_order_dt := max(cs_order_date), by = list(case_no)]
# court <- court[max_order_dt == cs_order_date]
# court[, c("group", "index", "max_order_dt") := NULL]
# court[, ordertype := as.character(ordertype)]
### insure ###
setnames(insure, "medicaid_related", "medicaid")
# make medicare column
insure[is.na(medicare_A) & is.na(medicare_B) & is.na(medicare_A_B) &
is.na(medicare_D), medicare := "N"]
insure[is.na(medicare), medicare := "Y"]
insure[, grep(x=names(insure), pattern="medicare_", value = TRUE) := NULL]
## remove certain primary and secondary insurance for listed 'insurances' ##
modify$not_ins <-
c(
"Assessed for Medicaid Expansion - Eligible",
"Assessed for Medicaid Expansion - Not Eligible",
"Autism", "Adoption Subsidy", "WRAPAROUND - LIVINGSTON")
setkey(insure, primary_ins)[J(modify$not_ins), primary_ins := NA]
setkey(insure, secondary_ins)[J(modify$not_ins), secondary_ins := NA]
setkey(insure, other_ins)[J(modify$not_ins), other_ins := NA]
# remove COFR consumers from results per Kelly B 11/4/2015
modify$cofr_cases <-
unique(insure[grep(x = primary_ins, pattern = "COFR"), case_no],
insure[grep(x = secondary_ins, pattern = "COFR"), case_no],
insure[grep(x = other_ins, pattern = "COFR"), case_no])
# insure[case_no %in% modify$cofr_cases,
# .SD, .SDc = c("case_no", "primary_ins")]
## Medicare HMO ##
# set medicare="Y" if consumer has HMO Medicare
insure[grep(x = primary_ins, pattern = "medicare", ignore.case = TRUE),
medicare := "Y"]
insure[grep(x = secondary_ins, pattern = "medicare",
ignore.case = TRUE), medicare := "Y"]
invisible(insure[grep(x = other_ins, pattern = "medicare",
ignore.case = TRUE), medicare := "Y"])
# remove medicare HMO from private insurance
insure[grep(x = primary_ins, pattern = "medicare", ignore.case = TRUE),
primary_ins := NA]
insure[grep(x = secondary_ins, pattern = "medicare",
ignore.case = TRUE), secondary_ins := NA]
invisible(insure[grep(x = other_ins, pattern = "medicare", ignore.case =
TRUE), other_ins := NA])
## make primary insurance column ##
insure[!is.na(primary_ins) | !is.na(secondary_ins) |
!is.na(other_ins), private_insurance := "Y"]
insure[is.na(primary_ins) & is.na(secondary_ins) & is.na(other_ins),
private_insurance := "N"]
# remove duplicates
insure <- unique(insure)
### make fund columns ###
# add MI Child to Medicaid
setkey(insure, medicaid)[J(c("Medicaid", "MI Child")), fund := "Medicaid"]
# spend-down
setkey(insure, medicaid)[J(c("S/D/N", "S/D/Y")), fund := "spend-down"]
invisible(setkey(insure, NULL))
insure[fund == "spend-down" &
waiver == "HAB Waiver", fund := "HAB spend-down"]
# per Kelly B on 9/25/2015
insure[is.na(fund) & waiver == "HAB Waiver", fund := "Medicaid"]
# insure[, table(waiver, medicaid)] #### checking ...
# HMP
insure[medicaid == "HMP", fund := "HMP"]
# grouping Medicare and private ins. together
insure[is.na(fund) &
(medicare == "Y" | private_insurance == "Y"),
fund := "Medicare/TPP"]
# GF consumers because they have no insurance (as far as we know)
insure[is.na(fund), fund := "GF"]
# remove medicaid columns
# insure[, c("medicaid", "waiver") := NULL]
# get rid of case_no NAs
insure <- insure[!is.na(case_no)]
### ins_detail ###
# ins_detail <- unique(ins_detail)
ins_detail <-
setkey(ins_detail, insurance_name)[!J(modify$not_ins)]
ins_detail <-
ins_detail[!grep(x = insurance_name, pattern = "COFR")]
ins_detail <-
ins_detail[!grep(x = insurance_name, pattern = "Medicare", ignore.case =
TRUE)]
add_private_ins <- merge(insure, ins_detail, all.y = TRUE,
by = "case_no")[!is.na(private_insurance)][private_insurance == "N"]
setkey(insure, case_no)[J(add_private_ins[,
unique(case_no)]), private_insurance := "Y"]
rm(add_private_ins, ins_detail)
### locus ###
# convert dates
date_cols = c("adm_date", "locus_date")
for (j in date_cols)
set(locus, j = j, value = as.Date(locus[[j]]))
rm(date_cols, j)
# locus disposition level
locus[is.na(override), disp := recommend]
locus[!is.na(override), disp := override]
# find recent admissions (last 6 months)
locus[, days_cmh_open := date_convert(input$end_date) - adm_date]
locus[between(days_cmh_open,-Inf, 182), open_status := "0 to 6 months"]
locus[between(days_cmh_open, 183, 364), open_status := "6 to 12 months"]
locus[, adm_diff := as.numeric(adm_date - locus_date)]
locus[, min_adm_diff := min(adm_diff), by = list(case_no)]
locus <- locus[min_adm_diff == adm_diff]
# remove unwanted columns
locus[, c("adm_diff", "min_adm_diff", "recommend",
"override", "adm_date") := NULL]
locus <- locus[!is.na(open_status)]
locus[, disp := trim(disp)]
locus[, disp := sapply(disp, aux$word_to_num)]
# cmh crisis ------------------------------------------------------------------
setnames(cmh_crisis, names(cmh_crisis), tolower(names(cmh_crisis)))
setnames(
cmh_crisis,
old = c("cpt_code", "medicaid_related"),
new = c("cpt", "medicaid")
)
# CRS is not a CMH team ... have Snow fix this
cmh_crisis <- cmh_crisis[!team=="Crisis Residential Services"]
cmh_crisis[, team := wccmh::cmh_recode(team)]
cmh_crisis[, program := wccmh::recode_team_prog(team)]
cmh_crisis[fb_unit_type, unit_type := unit_type,
on = c(cpt = "cpt", cpt_modifier = "mod")]
cmh_crisis[fb_unit_type, unit_type := unit_type,
on = c(cpt = "cpt", cpt_modifier = "mod")]
cmh_crisis[is.na(unit_type), unit_type := "missing"]
cmh_crisis[um_code_desc, cpt_desc := UM.Desc, on = c(cpt = "CPT.CD")]
modify$TCM_cmh <- cmh_crisis[cpt == "T1017" & program =="MI",
list(TCM = length(cpt)), by = case_no]
locus <- merge(locus, modify$TCM_cmh, all.x = TRUE, by = "case_no")
locus[is.na(TCM), TCM := 0]
### create prediction disposition ###
# consumers open less than 6 months
# locus[, pred_level := NA_integer_]
locus[open_status == "0 to 6 months", pred_level := disp]
locus[open_status == "6 to 12 months",
pred_TCM := 365 * TCM / as.integer(days_cmh_open)]
locus[open_status == "6 to 12 months",
pred_TCM_level := aux$levelTCM(pred_TCM)]
locus[open_status == "6 to 12 months",
pred_model := as.integer(days_cmh_open - 182) / 182 * pred_TCM_level +
(182 - as.integer(days_cmh_open - 182)) / 182 * disp]
locus[open_status == "6 to 12 months",
pred_round := pmin(round(pred_model), 3)]
locus[, replace_level := ifelse(!is.na(pred_round), pred_round, pred_level)]
locus[, setdiff(names(locus), c("case_no", "replace_level")) := NULL]
# non_cmh_crisis --------------------------------------------------------------
setnames(
non_cmh_crisis,
old = c("cpt_code", "medicaid_related", "team2"),
new = c("cpt", "medicaid", "team")
)
non_cmh_crisis[fb_unit_type, unit_type := unit_type,
on = c(cpt = "cpt", cpt_modifier = "mod")]
non_cmh_crisis[is.na(unit_type), unit_type := "missing"]
non_cmh_crisis[um_code_desc, cpt_desc := UM.Desc, on = c(cpt = "CPT.CD")]
#### aggregate data ####
x <- copy(non_cmh_crisis)
x[case_no==1136878 & cost==Inf]
x
x <- copy(dt)
# add fb cost
x[fb_cpt_mod_cost,
cost := units * i.unit_cost,
on = c("cpt" = "PRI PROCEDURE CODE", "cpt_modifier" = "MOD")]
# summarize based on unit_type
fb_cpt_mod_cost
library(wccmh)
fb_cpt_mod_cost
fb_unit_type
