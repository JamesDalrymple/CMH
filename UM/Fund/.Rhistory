result <- csv_to_rds(
csv_file = data_csv,
keep_cols = keep_cols,
rename_cols = rename_cols,
rm.original = rm.original
)
}  else if (length(data_rds) == 1) {
# load rds file
result <- readRDS(file = data_rds)
if (length(colnames(result)) > length(rename_cols)) {
result[, setdiff(colnames(result), rename_cols) := NULL]
saveRDS(object = result, file = data_rds)
}
return(result)
}
cmh$free_stand_hosp <- c(
"BCA of Detroit, LLC DBA BCA StoneCrest Center",
"Forest View Hospital",
"Havenwyck Hospital",
"Harbor Oaks",
"Henry Ford Kingswood Hospital",
"Pine Rest Christian Mental Health Services",
"The Behavioral Center of Michigan"
)
# #### merge multiple data.tables ####
# mergeDT <- function( DT, by, ...)
# {
#   for(t in seq_along(DT) ) {
#     setkeyv(DT[[t]], cols=NULL)
#     setkeyv(DT[[t]], cols=by)
#   }
#   result <- DT[[1]]
#   for(t in 2:length(DT) )
#   {
#     result <- merge(result, DT[[t]], by=by, ...)
#   }
#   setkeyv(result, by)
#   return(result)
# }
# clinical LOS function - if discharge is blank, use auth_exp
cmh$clinicalStay <- function(start, expiration, discharge) {
if (!is.na(discharge)) {
clinStay = discharge - start
} else {
clinStay = expiration - start
}
return(as.numeric(clinStay))
}
attach(cmh)
cmh <- new.env(parent=baseenv())
pkg_loader(packages = c("data.table", "english", "zoo", "RODBC"))
cmh$cmh_recode <- function(x) {
recode_string(x=x,
recode_key = list(
ACT = c("ACT", "WSH - ACT"),
DD = c("DD", "WSH - DD Adult", "DD Adult"),
MI = c("WSH - MI - Adult", "WSH - ATO", "MI", "MI Adult"),
Child = c("Child", "WSH - Children's Services", "Children's Services"),
"Child HB" = c("WSH - Children's Services - Home Based", "Child HB",
"Home Based"),
PORT = c("WSH - PATH/PORT"),
Access = c("Community Support and Treatment Services - CSTS",
"CSTS", "WSH - Access/Engagement", "Access"),
OBRA = c("WSH - OBRA"),
nonCMH = c("non-CMH", "Non-CMH")
))
}
# function for converting dates, could make it work for %y too later ----
cmh$date_convert <- function(x, format = "%m/%d/%Y", origin="1970-01-01") {
y = as.Date(x, format = format, origin=origin )
return(y)
}
# team to program recoding
cmh$recode_team_prog = function(x) {
vapply(
X = x, FUN = recode_string,
recode_key = list(
DD = c("DD Adult", "DD"),
MI = c("MI Adult", "ACT", "MI"),
"Y&F" = c("Youth & Family", "Y&F", "Child", "Child HB"),
Access = "Access",
"non-CMH" = c("nonCMH", "non-CMH", "Non-CMH", "OBRA", "PORT")
),
FUN.VALUE = as.character("one"),
USE.NAMES = FALSE
)
}
# factor core teams
cmh$cmh_teams_f <- function(x,
levels = c("ACT", "DD", "MI", "Child HB", "Child"),
level_order = NULL, ...) {
if (missing(level_order) || is.null(level_order)) {
level_order <- FALSE
} else {
level_order <- is.ordered(x)
}
result <- factor(
x, levels, labels = levels,
exclude = setdiff(x = x, levels), ordered = level_order
)
return(result)
}
## examples
# x2 <- cmh_teams_f(cmh_recode(sample_teams))
cmh$cmh_priority_dt <-
data.table(team = c("OBRA", "ACT", "DD", "MI", "Child HB", "Child",
"PATH/PORT", "Access", "non-CMH"))
cmh$cmh_priority_dt[, priority := .I]
cmh$recode_fund <- function(x) {
recode_key <- list(
Medicaid = c("Medicaid - State Plan",
"Medicaid - b3",
"Medicaid - Hab Sup Waiver",
"Medicaid - Acute Services",
"Medicaid - Partial Services",
"MIChild"),
"General Fund" = c("General Fund - Partial Services", "GF"),
"Healthy Michigan Plan" = c("HMP", "HMP-Acute Services"),
"Adult Benefit Waiver" = "Adult Benefit Waiver",
"Child Waiver" = "Child Waiver",
"ABW-Acute Services" = "ABW")
unknown <- setdiff(x, unlist(recode_key, use.names = FALSE))
recode_key$unknown <- unknown
vapply(
X = x, FUN = recode_string,
recode_key = recode_key,
FUN.VALUE = as.character("one"),
USE.NAMES = FALSE
)
}
# function to capitalize the first letter of a string
cmh$single_cap <- function(x) {
s <- strsplit(x, " ")[[1]]
paste(toupper(substring(s, 1, 1)), substring(s, 2),
sep = "", collapse = " ")
}
cmh$cap_first <- function(x) {sapply(x, single_cap, USE.NAMES = FALSE)}
# cap_first(c("level", "one"))
# locus: leveling words to number
cmh$locus_word2num <- function(x) {
word2num_dt <-
data.table(word = cap_first(paste("level", english::as.english(0:6))))
word2num_dt[, num := .I - 1]
word2num_dt[word == "Level Six", num := 3] # per Kelly B. 5/7/2015
result <- setkey(word2num_dt, word)[J(x), num]
return(result)
}
# # row-wise summing to be done preferrably in a data.table
# psum = function(..., na.rm=FALSE) {
#   if (na.rm) {
#     Reduce(`+`, ...)
#   } else {
#     Reduce(`+`, c(0, na.omit(...)))
#   }
# }
# convert csv to rds
cmh$csv_to_rds <-
function(csv_file, keep_cols, rename_cols = rename_cols, rm.original) {
csv_data <- read.dtable(csv_file)
rds_file <- gsub(x = csv_file, pattern = ".csv", replace = ".rds")
if (length(csv_data[, intersect(colnames(csv_data), keep_cols)])
!= length(keep_cols)) {
stop("keep_cols are not in original file! Check original file!")
}
suppressWarnings(csv_data[, setdiff(colnames(csv_data), keep_cols)
:= NULL])
setnames(csv_data, colnames(csv_data), rename_cols)
saveRDS(object = csv_data, file = rds_file)
if (rm.original) {
unlink(x = csv_file); print("original file deleted")
}
result <- readRDS(file = rds_file)
}
# load, save, compress data and delete original
cmh$load_data <-
function(file_pattern, keep_cols, rename_cols = rename_cols, rm.original =
FALSE) {
data_csv <- grep(
x = csv_files, pattern = file_pattern,
ignore.case = TRUE, value = TRUE, perl = TRUE
)
data_rds <- grep(
x = rds_files, pattern = file_pattern,
ignore.case = TRUE, value = TRUE
)
if (length(data_csv) == 0 &&
length(data_rds) == 0) {
stop("No file found with given pattern (csv or rds).")
}
if (length(data_csv) > 1) {
stop(paste("too many csv", file_pattern, "files!", sep = " - "))
}
if (length(data_csv) == 1) {
# load data_csv, keep only wanted columns, save as rds file,
# then load rds file, then delete data_csv file
result <- csv_to_rds(
csv_file = data_csv,
keep_cols = keep_cols,
rename_cols = rename_cols,
rm.original = rm.original
)
}  else if (length(data_rds) == 1) {
# load rds file
result <- readRDS(file = data_rds)
if (length(colnames(result)) > length(rename_cols)) {
result[, setdiff(colnames(result), rename_cols) := NULL]
saveRDS(object = result, file = data_rds)
}
return(result)
}
cmh$free_stand_hosp <- c(
"BCA of Detroit, LLC DBA BCA StoneCrest Center",
"Forest View Hospital",
"Havenwyck Hospital",
"Harbor Oaks",
"Henry Ford Kingswood Hospital",
"Pine Rest Christian Mental Health Services",
"The Behavioral Center of Michigan"
)
# #### merge multiple data.tables ####
# mergeDT <- function( DT, by, ...)
# {
#   for(t in seq_along(DT) ) {
#     setkeyv(DT[[t]], cols=NULL)
#     setkeyv(DT[[t]], cols=by)
#   }
#   result <- DT[[1]]
#   for(t in 2:length(DT) )
#   {
#     result <- merge(result, DT[[t]], by=by, ...)
#   }
#   setkeyv(result, by)
#   return(result)
# }
# clinical LOS function - if discharge is blank, use auth_exp
cmh$clinicalStay <- function(start, expiration, discharge) {
if (!is.na(discharge)) {
clinStay = discharge - start
} else {
clinStay = expiration - start
}
return(as.numeric(clinStay))
}
attach(cmh)
cmh <- new.env(parent=baseenv())
pkg_loader(packages = c("data.table", "english", "zoo", "RODBC"))
cmh$cmh_recode <- function(x) {
recode_string(x=x,
recode_key = list(
ACT = c("ACT", "WSH - ACT"),
DD = c("DD", "WSH - DD Adult", "DD Adult"),
MI = c("WSH - MI - Adult", "WSH - ATO", "MI", "MI Adult"),
Child = c("Child", "WSH - Children's Services", "Children's Services"),
"Child HB" = c("WSH - Children's Services - Home Based", "Child HB",
"Home Based"),
PORT = c("WSH - PATH/PORT"),
Access = c("Community Support and Treatment Services - CSTS",
"CSTS", "WSH - Access/Engagement", "Access"),
OBRA = c("WSH - OBRA"),
nonCMH = c("non-CMH", "Non-CMH")
))
}
# function for converting dates, could make it work for %y too later ----
cmh$date_convert <- function(x, format = "%m/%d/%Y", origin="1970-01-01") {
y = as.Date(x, format = format, origin=origin )
return(y)
}
# team to program recoding
cmh$recode_team_prog = function(x) {
vapply(
X = x, FUN = recode_string,
recode_key = list(
DD = c("DD Adult", "DD"),
MI = c("MI Adult", "ACT", "MI"),
"Y&F" = c("Youth & Family", "Y&F", "Child", "Child HB"),
Access = "Access",
"non-CMH" = c("nonCMH", "non-CMH", "Non-CMH", "OBRA", "PORT")
),
FUN.VALUE = as.character("one"),
USE.NAMES = FALSE
)
}
# factor core teams
cmh$cmh_teams_f <- function(x,
levels = c("ACT", "DD", "MI", "Child HB", "Child"),
level_order = NULL, ...) {
if (missing(level_order) || is.null(level_order)) {
level_order <- FALSE
} else {
level_order <- is.ordered(x)
}
result <- factor(
x, levels, labels = levels,
exclude = setdiff(x = x, levels), ordered = level_order
)
return(result)
}
## examples
# x2 <- cmh_teams_f(cmh_recode(sample_teams))
cmh$cmh_priority_dt <-
data.table(team = c("OBRA", "ACT", "DD", "MI", "Child HB", "Child",
"PATH/PORT", "Access", "non-CMH"))
cmh$cmh_priority_dt[, priority := .I]
cmh$recode_fund <- function(x) {
recode_key <- list(
Medicaid = c("Medicaid - State Plan",
"Medicaid - b3",
"Medicaid - Hab Sup Waiver",
"Medicaid - Acute Services",
"Medicaid - Partial Services",
"MIChild"),
"General Fund" = c("General Fund - Partial Services", "GF"),
"Healthy Michigan Plan" = c("HMP", "HMP-Acute Services"),
"Adult Benefit Waiver" = "Adult Benefit Waiver",
"Child Waiver" = "Child Waiver",
"ABW-Acute Services" = "ABW")
unknown <- setdiff(x, unlist(recode_key, use.names = FALSE))
recode_key$unknown <- unknown
vapply(
X = x, FUN = recode_string,
recode_key = recode_key,
FUN.VALUE = as.character("one"),
USE.NAMES = FALSE
)
}
# function to capitalize the first letter of a string
cmh$single_cap <- function(x) {
s <- strsplit(x, " ")[[1]]
paste(toupper(substring(s, 1, 1)), substring(s, 2),
sep = "", collapse = " ")
}
cmh$cap_first <- function(x) {sapply(x, single_cap, USE.NAMES = FALSE)}
# cap_first(c("level", "one"))
# locus: leveling words to number
cmh$locus_word2num <- function(x) {
word2num_dt <-
data.table(word = cap_first(paste("level", english::as.english(0:6))))
word2num_dt[, num := .I - 1]
word2num_dt[word == "Level Six", num := 3] # per Kelly B. 5/7/2015
result <- setkey(word2num_dt, word)[J(x), num]
return(result)
}
# # row-wise summing to be done preferrably in a data.table
# psum = function(..., na.rm=FALSE) {
#   if (na.rm) {
#     Reduce(`+`, ...)
#   } else {
#     Reduce(`+`, c(0, na.omit(...)))
#   }
# }
# convert csv to rds
cmh$csv_to_rds <-
function(csv_file, keep_cols, rename_cols = rename_cols, rm.original) {
csv_data <- read.dtable(csv_file)
rds_file <- gsub(x = csv_file, pattern = ".csv", replace = ".rds")
if (length(csv_data[, intersect(colnames(csv_data), keep_cols)])
!= length(keep_cols)) {
stop("keep_cols are not in original file! Check original file!")
}
suppressWarnings(csv_data[, setdiff(colnames(csv_data), keep_cols)
:= NULL])
setnames(csv_data, colnames(csv_data), rename_cols)
saveRDS(object = csv_data, file = rds_file)
if (rm.original) {
unlink(x = csv_file); print("original file deleted")
}
result <- readRDS(file = rds_file)
}
# load, save, compress data and delete original
cmh$load_data <-
function(file_pattern, keep_cols, rename_cols = rename_cols, rm.original =
FALSE) {
data_csv <- grep(
x = csv_files, pattern = file_pattern,
ignore.case = TRUE, value = TRUE, perl = TRUE
)
data_rds <- grep(
x = rds_files, pattern = file_pattern,
ignore.case = TRUE, value = TRUE
)
if (length(data_csv) == 0 &&
length(data_rds) == 0) {
stop("No file found with given pattern (csv or rds).")
}
if (length(data_csv) > 1) {
stop(paste("too many csv", file_pattern, "files!", sep = " - "))
}
if (length(data_csv) == 1) {
# load data_csv, keep only wanted columns, save as rds file,
# then load rds file, then delete data_csv file
result <- csv_to_rds(
csv_file = data_csv,
keep_cols = keep_cols,
rename_cols = rename_cols,
rm.original = rm.original
)
}  else if (length(data_rds) == 1) {
# load rds file
result <- readRDS(file = data_rds)
if (length(colnames(result)) > length(rename_cols)) {
result[, setdiff(colnames(result), rename_cols) := NULL]
saveRDS(object = result, file = data_rds)
}
return(result)
}
cmh$free_stand_hosp <- c(
"BCA of Detroit, LLC DBA BCA StoneCrest Center",
"Forest View Hospital",
"Havenwyck Hospital",
"Harbor Oaks",
"Henry Ford Kingswood Hospital",
"Pine Rest Christian Mental Health Services",
"The Behavioral Center of Michigan"
)
# #### merge multiple data.tables ####
# mergeDT <- function( DT, by, ...)
# {
#   for(t in seq_along(DT) ) {
#     setkeyv(DT[[t]], cols=NULL)
#     setkeyv(DT[[t]], cols=by)
#   }
#   result <- DT[[1]]
#   for(t in 2:length(DT) )
#   {
#     result <- merge(result, DT[[t]], by=by, ...)
#   }
#   setkeyv(result, by)
#   return(result)
# }
# clinical LOS function - if discharge is blank, use auth_exp
cmh$clinicalStay <- function(start, expiration, discharge) {
if (!is.na(discharge)) {
clinStay = discharge - start
} else {
clinStay = expiration - start
}
return(as.numeric(clinStay))
}
attach(cmh)
while ("cmh" %in% search()) {
detach(cmh)
}
## to do:: remove state hospital consumers from all spreadsheets
# initializing working directory and input parameters -------------------------
rm(list = ls()) # clear RAM
# which computer results in correct base working directory
cmh_wd <-
data.table::data.table(expand.grid(stringsAsFactors = FALSE,
dir_names = c("Dropbox", "GitHub"),
comp_names = c("WSHSQLGP", "DESKTOP-45K7RRN", "JAMES-2"),
base = "filler"))
data.table::setkey(cmh_wd, dir_names, comp_names)[
J("Dropbox", "WSHSQLGP"), base := "C:/Users/dalrymplej/Dropbox"]
data.table::setkey(cmh_wd, dir_names, comp_names)[
J("GitHub", "WSHSQLGP"), base := "C:/Users/dalrymplej/Documents/GitHub"]
project_wd <- list()
project_wd$github <- cmh_wd[J("GitHub", "WSHSQLGP"), base]
project_wd$dropbox <- cmh_wd[J("Dropbox", "WSHSQLGP"), base]
project_wd$project <- "CMH/UM/Fund"
project_wd$code <- file.path(project_wd$github, project_wd$project, "Code")
project_wd$data <- file.path(project_wd$dropbox,
"Utilization Management/Fund Only/Data")
project_wd$results <- "Utilization Management/Fund Only/Results"
rm(cmh_wd)
# user input ------------------------------------------------------------------
user_input <- list(
run_date = "9/22/2015",
end_date = "8/31/2015" # data parameter end
)
# for folder
project_wd$data <- file.path(project_wd$data,
gsub(
x = user_input$run_date,
pattern = "/",
replace = "_"
))
# load packages, source files -------------------------------------------------
# library(CMH) ... replacing global script at some point
source(file.path(project_wd$dropbox, "WCCMH/R/global library.R"))
source(file.path(project_wd$code, "0_service auxillary.R"))
format(as.Date(user_input$run_date), "%m_%d_%y")
format(date_convert(user_input$run_date), "%m_%d_%y")
user_input
format(date_convert(c(user_input$run_date, user_input$run_date)), "%m_%d_%y")
date_search <-
format(date_convert(c(
user_input$end_date, user_input$run_date
)), "%m_%d_%y")
sql <- new.env(parent=baseenv())
assign(x = search_dates, value =
format(date_convert(c(
user_input$end_date, user_input$run_date
)), "%m_%d_%y"),
envir = sql
)
assign(x = "search_dates", value =
format(date_convert(c(
user_input$end_date, user_input$run_date
)), "%m_%d_%y"),
envir = sql
)
sql
sql$search_dates
with(sql, search_dates)
sql <- new.env(parent=as.environment("aux"))
assign(x = "search_dates", value =
format(date_convert(c(
user_input$end_date, user_input$run_date
)), "%m_%d_%y"),
envir = sql
)
with(sql, search_dates)
