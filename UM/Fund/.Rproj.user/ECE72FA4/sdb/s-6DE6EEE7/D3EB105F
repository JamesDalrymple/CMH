{
    "collab_server" : "",
    "contents" : "# Install/Load packages ----\n  usePackage <- function(packages, ...) {\n    # only install new packages\n    newPackages <- packages[!(packages %in% installed.packages()[, \"Package\"])]\n    if( length(newPackages) > 0 ) {\n      install.packages(newPackages, dependencies=TRUE)\n      # install.packages(newPackages, repos=\"http://cran.mtu.edu/\", lib=.Library)\n    }\n    # load all packages\n    sapply(packages, require, character.only=TRUE)\n  }\n  packages <- c(\"data.table\", \"ggplot2\", \"zoo\", \"xlsx\", \"gdata\",\n              \"reshape\", \"ggmap\", \"shiny\", \"grid\", \"sqldf\",\n              \"XML\", \"RCurl\", \"xtable\", \"knitr\", \"reshape2\") # \"MASS\"\n  # update packages\n  # pkgsToUp <- as.character(old.packages()[, \"Package\"])\n\n  # if(length(pkgsToUp)>0) {\n  #   update.packages(oldPkgs=pkgsToUp, ask=FALSE)\n  #   print(paste(\"These packages were updated:\", paste(pkgsToUp, sep=\"\", collapse=\", \")))\n  # }\n  usePackage(packages=packages)\n  rm(packages)\n\n# negation of '%in%'\n  `%nin%` <- Negate(`%in%`)\n\n# Function for inserting expressions which changes features\n  parse.inst <- function(...) {parse( text = paste(..., sep=\"\"))}\n  # note: use  eval(parse.inst(v1, v2,  ... )) to excute the expersion\n  # example: eval(parse.inst(\"testMe = 1\"))\n\n# utilization management colors ----\n  um_colors = c(\"#94B6D2\", \"#DD8047\", \"#EBDDC3\", \"#775F55\", \"#B6C999\")\n\n# function for converting dates ----\n  dateConvert = function(x, format = \"%m/%d/%Y\", origin=\"1970-01-01\") {\n    y = as.Date(x, format = format, origin=origin )\n    return(y)\n  }\n\n# remove '$' symbol and ',' from dollar strings, and convert to numeric ----\n  moneyRm = function(x) {\n    result = gsub(x = x, pattern = \"[$,)]\", replacement = \"\" )\n    result = gsub(x = result, pattern = \"[(]\", replacement= \"-\")\n    result = as.numeric(result)\n    return(result)\n  }\n\n# add '$' symbol and K, M as appropriate for ggplot graphing ----\n  moneyAdd = function(x) {\n    # if missing values exist, replace result with missing values\n    if(is.na(x)==TRUE) { moneyLab = NA_character_ } else\n      # millions\n      if(x>1e6) {\n        moneyLab = paste(\"$\", round(x/1e6,2), \"M\", sep=\"\")\n      } else\n        # thousands\n        if(x<1e6) {\n          moneyLab = paste(\"$\", round(x/1e3,0), \"K\", sep=\"\")\n        } else\n          # less than 1000\n          if(x<1e3) {\n            moneyLab =  paste(\"$\", x, sep=\"\")\n          }\n    return(moneyLab)\n  }\n\n# ageConvert ----\n  ageFn = function(x) { return(floor(as.numeric(Sys.Date() -\n                               dateConvert(x))/365.25)) }\n\n# function to handle errors\n  tryCatch.W.E <- function(expr) {\n    W <- NULL\n    w.handler <- function(w){ # warning handler\n      W <<- w\n      invokeRestart(\"muffleWarning\")\n    }\n    list(value = withCallingHandlers(tryCatch(expr, error = function(e) e),\n                                     warning = w.handler),\n         warning = W)\n  }\n\n  # read in data.table ----\n  ## todo: use fread\n  read.dtable = function(file, na.strings = c(\"NA\", \"NULL\"), stringsAsFactors =\n                           FALSE, nrows = -1, ...) {\n    # read first line of file, to avoid reading in large datasets twice or copying large datsets\n    fileExists = tryCatch.W.E(read.table(\n      file, header = TRUE, nrow = 1, sep = \",\", strip.white = TRUE, ...\n    ))\n    if (!is.null(fileExists$warning)) {\n      return(stop(\"File does not exist in current working directory.\"))\n    } else{\n      dtable = data.table(trim(\n        read.csv(\n          file, stringsAsFactors = stringsAsFactors,\n          strip.white = TRUE, na.strings =\n            na.strings, nrows = nrows, ...\n        )\n      ))\n    }\n    return(dtable)\n  }\n\n# function for creating a fiscal year from month (date class) ----\n  my_fy = function(x, format = \"%m/%d/%Y\" ) {\n    if( class(x)!=\"Date\" ) { x = as.Date(x, format = format)}\n    quarter = as.yearqtr(x)+.25\n    year = as.character(substr(quarter, 1, 4))\n    return(year)\n  }\n\n# function for creating fiscal from quarter (date class) ----\n  my_qtr = function(x, format = \"%m/%d/%Y\") {\n    if( class(x)!=\"Date\" ) { x = as.Date(x, format = format)}\n    quarter = as.yearqtr(x)+.25\n    quarter = as.character(quarter)\n    return(quarter)\n  }\n\n# function for creating current fiscal year quarters, where a quarter must be completed to show up\n  dt_fy_qtrs <- function(input_date=Sys.Date()) {\n    input_date <- dateConvert(input_date)\n    fy_start <- paste0(\"10/1/\", as.numeric(my_fy(input_date))-1)\n    fy_qtrs <- data.table(\n      start_date = as.Date(as.yearqtr(dateConvert(fy_start))+seq(0, 0.75, .25), frac=0),\n      end_date = as.Date(as.yearqtr(dateConvert(fy_start))+seq(0, 0.75, .25), frac=1)\n    )\n    fy_qtrs[, qtr := my_qtr(start_date)]\n    fy_qtrs <- fy_qtrs[end_date <= input_date]\n    return(fy_qtrs)\n  }\n\n# quarter function from Jessica S.\n   # If date in (10,11,12) then quarter=1;\n   # Else quarter=round((month(date)/3+0.4))+1;\n\n# my_theme for ggplot----\n  my_theme=  theme(legend.position = \"topleft\",\n                   panel.background = element_rect(fill = \"white\", colour = NA),\n                   panel.border = element_rect(fill = NA,\n                                               colour = \"grey50\"),\n                   panel.grid.major = element_line(colour = \"white\",size = 0.2),\n                   panel.grid.minor = element_line(colour = \"white\",\n                                                   size = .2 ),\n                   strip.background = element_rect(fill = \"white\", colour = \"white\"),\n                   axis.title.x = element_text(colour = \"white\"),\n                   axis.title.y = element_text(colour = \"white\"),\n                   plot.title = element_text(size=10))\n\n# a max function that allows all NA inputs----\n  my_max = function(x) {    options(warn=-1)\n                            step1 = max( x, na.rm = TRUE)\n                            if( is.finite(step1) ) {ans = step1} else{\n                              ans = NA_real_\n                            }\n                            return(as.numeric(ans))\n  }\n\n# specificy the number of decimals\n  specify_decimal <- function(x, k) format(round(x, k), nsmall=k)\n\n # function to place two ggplots on one pdf----\n  multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {\n    require(grid)\n\n    # Make a list from the ... arguments and plotlist\n    plots <- c(list(...), plotlist)\n\n    numPlots = length(plots)\n\n    # If layout is NULL, then use 'cols' to determine layout\n    if (is.null(layout)) {\n      # Make the panel\n      # ncol: Number of columns of plots\n      # nrow: Number of rows needed, calculated from # of cols\n      layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),\n                       ncol = cols, nrow = ceiling(numPlots/cols))\n    }\n\n    if (numPlots==1) {\n      print(plots[[1]])\n\n    } else {\n      # Set up the page\n      grid.newpage()\n      pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))\n\n      # Make each plot, in the correct location\n      for (i in 1:numPlots) {\n        # Get the i,j matrix positions of the regions that contain this subplot\n        matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))\n\n        print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,\n                                        layout.pos.col = matchidx$col))\n      }\n    }\n  }\n\n# function to trim off top 15 % then take the mean----\n  meanTrim = function(x, trim=.15) {\n    x = x[!is.na(x)]\n    xOrd = x[order(x)]\n    xReduce = xOrd[1:round((1-trim)*length(xOrd)) ]\n    result = mean(xReduce)\n    return(result)\n  }\n\n# function to capitalize the first letter of a string\n  simpleCap <- function(x) {\n    s <- strsplit(x, \" \")[[1]]\n    paste(toupper(substring(s, 1,1)), substring(s, 2),\n          sep=\"\", collapse=\" \")\n  }\n\n# function to replace multiple values\n  replacer <- function(x, old, new) {\n    result = new[ match(x, old)]\n    return(result)\n  }\n  # example:\n  # x = c(rep('x',3),rep('y',3), NA, rep('z',3), NA)\n  # replacer(x, old=c(\"x\",\"y\",\"z\"), new=as.character(1:3))\n\n# max function to deal with integers and NAs and Inf\n  my_max <- function(x) {options(warn=-1)\n                        result = max(as.numeric(x), na.rm=TRUE)\n                        if(!is.finite(result)) {result=NA_real_}\n                        return(result)}\n# min function to deal with integers and NAs and Inf\n  my_min = function(x) {options(warn=-1)\n                        result = min(as.numeric(x), na.rm=TRUE)\n                        if(!is.finite(result)) {result=NA_real_}\n                        return(result)}\n\n# function to take vectors of equal length and sum them row-wise\n  psum = function(a, b, ...) {\n    # if multiple arguments are passed...\n    extraVars = list(...)\n    # if extraVars exist ...\n    if(length(extraVars)>0) {\n      my_mat = matrix(ncol=length(extraVars), nrow=length(extraVars[[1]]))\n      for( i in seq(extraVars) ) {\n        my_mat[,i] = extraVars[[i]]\n      }\n      # combine extra variables to first 2 variables\n      dat = data.frame(a=a, b=b, my_mat)\n    } else (dat = data.frame(a=a, b=b))\n    # compute the row sums and return result as a vector\n    result = rowSums( dat, na.rm = TRUE)\n    return(result)\n  }\n\n#### merge multiple data.tables ####\n\nmergeDT <- function( DT, by, ...)\n  {\n  for(t in seq_along(DT) ) {\n    setkeyv(DT[[t]], cols=NULL)\n    setkeyv(DT[[t]], cols=by)\n  }\n    result <- DT[[1]]\n    for(t in 2:length(DT) )\n    {\n      result <- merge(result, DT[[t]], by=by, ...)\n    }\n    setkeyv(result, by)\n    return(result)\n  }\n\n# function to create boxplot with jittered outliers with optional log and facet features #\nbpJitter = function(dataset, xVar, yVar, group=NULL, jitter.x=0.2,\n                    title.plot=NULL, title.x.axis=NULL, title.y.axis=NULL, logBase=NULL,\n                    xlabAngle=0) {\n  # copy data to avoid changing original data.table\n  data = copy(dataset)\n  # if logBase is not null...\n    if(!is.null(logBase)) {\n      # transform the data\n      data[, eval(yVar) := as.numeric(get(yVar))] # numeric to make sure next line works\n      # set 0 to 1 works for discrete data... may need a different method for continuous datasets\n      data[get(yVar)==0, eval(yVar) := 1 ]\n      data[, eval(yVar) := log( get(yVar)+1e-7, base=logBase) ]\n\n      # change the title.y.axis to include log 2 at the front\n      title.y.axis = paste(\"Log\", logBase, \"of\", title.y.axis)\n    }\n\n  # make jitteredFy for boxplot jittering\n    data[, jitterTime := psum(as.numeric(factor(get(xVar))), runif(get(xVar), min=-jitter.x, max=jitter.x))]\n    ## outliers ##\n    if(is.null(group)) {\n      # first quartile\n        data[, q1 := .SD[, quantile(x=get(yVar), probs=0.25, type=7, na.rm=TRUE)], by=xVar]\n      # third quartile\n        data[, q3 := .SD[, quantile(x=get(yVar), probs=0.75, type=7, na.rm=TRUE)], by=xVar]\n    } else {\n      # first quartile\n      data[, q1 := .SD[, quantile(x=get(yVar), probs=0.25, type=7, na.rm=TRUE)], by=c(xVar, group)]\n      # third quartile\n      data[, q3 := .SD[, quantile(x=get(yVar), probs=0.75, type=7, na.rm=TRUE)], by=c(xVar, group)]\n    }\n    # outlier column\n    data[ get(yVar) > q3+1.5*(q3-q1) | get(yVar) < q1-1.5*(q3-q1), outliers := \"Y\"]\n    data[!( get(yVar) > q3+1.5*(q3-q1) | get(yVar) < q1-1.5*(q3-q1)), outliers := \"N\"]\n    # create boxplot\n      p.boxplot = ggplot(data=data, aes_string(x=xVar, y=yVar))+\n        geom_point(data=data[outliers==\"Y\"], aes_string(x=\"jitterTime\", y=yVar),\n                   size=1.5, alpha=0.4, shape=3, color=um_colors[4])+\n        geom_boxplot(data=data, aes_string(x=xVar, y=yVar),\n                     outlier.size=NA, position=position_dodge(.6), width=.6,\n                     fill=um_colors[1], fatten = 1, color=um_colors[4])\n      # make a facet if group is not null\n      if(!is.null(group)) {\n        facets = facet_wrap(formula(paste(\"~\", group)), scales=\"free\")\n        p.boxplot = p.boxplot + facets\n      }\n      # add remainder of plot updates\n      p.boxplot = p.boxplot+my_theme+labs(title=title.plot, x=title.x.axis, y=title.y.axis)+\n        theme(legend.position = \"topleft\",\n              panel.background = element_rect(fill = \"white\", colour = NA),\n              panel.border = element_rect(fill = NA, colour = \"grey80\"),\n              panel.grid.major = element_line(colour = \"grey70\", size = 0.2),\n              panel.grid.minor = element_line(colour = \"grey85\", size = .2),\n              strip.background = element_rect(fill = \"white\", colour = \"white\"),\n              axis.title.x = element_text(colour = \"grey30\", size=8),\n              axis.title.y = element_text(colour = \"grey30\", size=8),\n              axis.text.x = element_text(size=7, angle=xlabAngle),\n              axis.text.y = element_text(size=7) )+\n        scale_x_discrete()\n  return(p.boxplot)\n}\n\n# function to see if user input is a color\n  areColors <- function(x) {\n    sapply(x, function(X) {\n      tryCatch(is.matrix(col2rgb(X)),\n               error = function(e) FALSE)\n    })\n  }\n\n# print function\n  auto.print = function( ... ) {\n    Rinput = c(...)\n    result = NULL\n    for( i in seq_along(Rinput)) {\n      result = paste(result, names(Rinput)[i],\n                     \": \", Rinput[i], \" | \", collapse=\"\", sep=\"\")\n    }\n    return( substr(result, 1, nchar(result)-1) )\n  }\n\n# function to create new subfolder in a given main directory\n  createWD = function(mainDir, subDir) {\n    if (file.exists(paste(mainDir, subDir, \"/\", sep = \"/\", collapse = \"/\"))) {\n      cat(\"subDir exists in mainDir and is a directory\")\n    } else if (file.exists(paste(mainDir, subDir, sep = \"/\", collapse = \"/\"))) {\n      cat(\"subDir exists in mainDir but is a file\")\n      # you will probably want to handle this separately\n    } else {\n      cat(\"subDir does not exist in mainDir - creating\")\n      dir.create(file.path(mainDir, subDir))\n    }\n  }\n\n# save variables via list[...]\n  list <- structure(NA,class=\"result\")\n  \"[<-.result\" <- function(x,...,value) {\n    args <- as.list(match.call())\n    args <- args[-c(1:2,length(args))]\n    length(value) <- length(args)\n    for(i in seq(along=args)) {\n      a <- args[[i]]\n      if(!missing(a)) eval.parent(substitute(a <- v,list(a=a,v=value[[i]])))\n    }\n    x\n  }\n  # # it is used like this:\n  #\n  # list[QR,,QRaux]  <- qr(c(1,1:3,3:1)) # saves the 1st results to QR, and the 3rd results to QRaux\n  # QR\n  # QRaux\n  #\n  # list[,Green,Blue]  <- col2rgb(\"aquamarine\") # saves the 2nd results to Green, and the 3rd results to Blue\n  # Green\n  # Blue\n",
    "created" : 1445362257442.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "386688659",
    "id" : "D3EB105F",
    "lastKnownWriteTime" : 1443708648,
    "path" : "C:/Users/dalrymplej/Dropbox/WCCMH/R/begin script R code.r",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}