{
    "collab_server" : "",
    "contents" : "# GLOBAL LIBRARY 0.1\n# clear RAM\nlibrary(EquaPac)\n\nwhile (\"cmh\" %in% search()) {\n  detach(cmh)\n}\n\ncmh <- new.env(parent=baseenv())\npkg_loader(packages = c(\"data.table\", \"english\", \"zoo\", \"RODBC\"))\n\ncmh$cmh_recode <- function(x) {\n  recode_string(x=x,\n                recode_key = list(\n    ACT = c(\"ACT\", \"WSH - ACT\"),\n    DD = c(\"DD\", \"WSH - DD Adult\", \"DD Adult\"),\n    MI = c(\"WSH - MI - Adult\", \"WSH - ATO\", \"MI\", \"MI Adult\"),\n    Child = c(\"Child\", \"WSH - Children's Services\", \"Children's Services\"),\n    \"Child HB\" = c(\"WSH - Children's Services - Home Based\", \"Child HB\",\n                   \"Home Based\"),\n    PORT = c(\"WSH - PATH/PORT\"),\n    Access = c(\"Community Support and Treatment Services - CSTS\",\n               \"CSTS\", \"WSH - Access/Engagement\", \"Access\"),\n    OBRA = c(\"WSH - OBRA\"),\n    nonCMH = c(\"non-CMH\", \"Non-CMH\")\n  ))\n}\n\n# function for converting dates, could make it work for %y too later ----\ncmh$date_convert <- function(x, format = \"%m/%d/%Y\", origin=\"1970-01-01\") {\n  y = as.Date(x, format = format, origin=origin )\n  return(y)\n}\n\n\n# team to program recoding\ncmh$recode_team_prog = function(x) {\n  vapply(\n    X = x, FUN = recode_string,\n    recode_key = list(\n      DD = c(\"DD Adult\", \"DD\"),\n      MI = c(\"MI Adult\", \"ACT\", \"MI\"),\n      \"Y&F\" = c(\"Youth & Family\", \"Y&F\", \"Child\", \"Child HB\"),\n      Access = \"Access\",\n      \"non-CMH\" = c(\"nonCMH\", \"non-CMH\", \"Non-CMH\", \"OBRA\", \"PORT\")\n    ),\n    FUN.VALUE = as.character(\"one\"),\n    USE.NAMES = FALSE\n  )\n}\n\n# factor core teams\ncmh$cmh_teams_f <- function(x,\n                        levels = c(\"ACT\", \"DD\", \"MI\", \"Child HB\", \"Child\"),\n                        level_order = NULL, ...) {\n  if (missing(level_order) || is.null(level_order)) {\n    level_order <- FALSE\n  } else {\n    level_order <- is.ordered(x)\n  }\n  result <- factor(\n    x, levels, labels = levels,\n    exclude = setdiff(x = x, levels), ordered = level_order\n  )\n  return(result)\n}\n\n## examples\n# x2 <- cmh_teams_f(cmh_recode(sample_teams))\n\ncmh$cmh_priority_dt <-\n  data.table(team = c(\"OBRA\", \"ACT\", \"DD\", \"MI\", \"Child HB\", \"Child\",\n                  \"PATH/PORT\", \"Access\", \"non-CMH\"))\ncmh$cmh_priority_dt[, priority := .I]\n\ncmh$recode_fund <- function(x) {\n  recode_key <- list(\n    Medicaid = c(\"Medicaid - State Plan\",\n                 \"Medicaid - b3\",\n                 \"Medicaid - Hab Sup Waiver\",\n                 \"Medicaid - Acute Services\",\n                 \"Medicaid - Partial Services\",\n                 \"MIChild\"),\n    \"General Fund\" = c(\"General Fund - Partial Services\", \"GF\"),\n    \"Healthy Michigan Plan\" = c(\"HMP\", \"HMP-Acute Services\"),\n    \"Adult Benefit Waiver\" = \"Adult Benefit Waiver\",\n    \"Child Waiver\" = \"Child Waiver\",\n    \"ABW-Acute Services\" = \"ABW\")\n  unknown <- setdiff(x, unlist(recode_key, use.names = FALSE))\n  recode_key$unknown <- unknown\n  vapply(\n    X = x, FUN = recode_string,\n    recode_key = recode_key,\n    FUN.VALUE = as.character(\"one\"),\n    USE.NAMES = FALSE\n  )\n}\n\n# function to capitalize the first letter of a string\ncmh$single_cap <- function(x) {\n  s <- strsplit(x, \" \")[[1]]\n  paste(toupper(substring(s, 1, 1)), substring(s, 2),\n        sep = \"\", collapse = \" \")\n}\ncmh$cap_first <- function(x) {sapply(x, single_cap, USE.NAMES = FALSE)}\n# cap_first(c(\"level\", \"one\"))\n\n# locus: leveling words to number\ncmh$locus_word2num <- function(x) {\n  word2num_dt <-\n    data.table(word = cap_first(paste(\"level\", english::as.english(0:6))))\n  word2num_dt[, num := .I - 1]\n  word2num_dt[word == \"Level Six\", num := 3] # per Kelly B. 5/7/2015\n  result <- setkey(word2num_dt, word)[J(x), num]\n  return(result)\n}\n\n# # row-wise summing to be done preferrably in a data.table\n# psum = function(..., na.rm=FALSE) {\n#   if (na.rm) {\n#     Reduce(`+`, ...)\n#   } else {\n#     Reduce(`+`, c(0, na.omit(...)))\n#   }\n# }\n\n# convert csv to rds\ncmh$csv_to_rds <-\n  function(csv_file, keep_cols, rename_cols = rename_cols, rm.original) {\n    csv_data <- read.dtable(csv_file)\n    rds_file <- gsub(x = csv_file, pattern = \".csv\", replace = \".rds\")\n\n    if (length(csv_data[, intersect(colnames(csv_data), keep_cols)])\n        != length(keep_cols)) {\n      stop(\"keep_cols are not in original file! Check original file!\")\n    }\n    suppressWarnings(csv_data[, setdiff(colnames(csv_data), keep_cols)\n                              := NULL])\n    setnames(csv_data, colnames(csv_data), rename_cols)\n    saveRDS(object = csv_data, file = rds_file)\n    if (rm.original) {\n      unlink(x = csv_file); print(\"original file deleted\")\n    }\n    result <- readRDS(file = rds_file)\n  }\n\n# load, save, compress data and delete original\ncmh$load_data <-\n  function(file_pattern, keep_cols, rename_cols = rename_cols, rm.original =\n             FALSE) {\n    data_csv <- grep(\n      x = csv_files, pattern = file_pattern,\n      ignore.case = TRUE, value = TRUE, perl = TRUE\n    )\n    data_rds <- grep(\n      x = rds_files, pattern = file_pattern,\n      ignore.case = TRUE, value = TRUE\n    )\n    if (length(data_csv) == 0 &&\n        length(data_rds) == 0) {\n      stop(\"No file found with given pattern (csv or rds).\")\n    }\n    if (length(data_csv) > 1) {\n      stop(paste(\"too many csv\", file_pattern, \"files!\", sep = \" - \"))\n    }\n    if (length(data_csv) == 1) {\n      # load data_csv, keep only wanted columns, save as rds file,\n      # then load rds file, then delete data_csv file\n      result <- csv_to_rds(\n        csv_file = data_csv,\n        keep_cols = keep_cols,\n        rename_cols = rename_cols,\n        rm.original = rm.original\n      )\n    }  else if (length(data_rds) == 1) {\n      # load rds file\n      result <- readRDS(file = data_rds)\n      if (length(colnames(result)) > length(rename_cols)) {\n        result[, setdiff(colnames(result), rename_cols) := NULL]\n        saveRDS(object = result, file = data_rds)\n      }\n    }\n    return(result)\n  }\n\ncmh$free_stand_hosp <- c(\n  \"BCA of Detroit, LLC DBA BCA StoneCrest Center\",\n  \"Forest View Hospital\",\n  \"Havenwyck Hospital\",\n  \"Harbor Oaks\",\n  \"Henry Ford Kingswood Hospital\",\n  \"Pine Rest Christian Mental Health Services\",\n  \"The Behavioral Center of Michigan\"\n)\n\n# #### merge multiple data.tables ####\n# mergeDT <- function( DT, by, ...)\n# {\n#   for(t in seq_along(DT) ) {\n#     setkeyv(DT[[t]], cols=NULL)\n#     setkeyv(DT[[t]], cols=by)\n#   }\n#   result <- DT[[1]]\n#   for(t in 2:length(DT) )\n#   {\n#     result <- merge(result, DT[[t]], by=by, ...)\n#   }\n#   setkeyv(result, by)\n#   return(result)\n# }\n\n# clinical LOS function - if discharge is blank, use auth_exp\ncmh$clinicalStay <- function(start, expiration, discharge) {\n  if (!is.na(discharge)) {\n    clinStay = discharge - start\n  } else {\n    clinStay = expiration - start\n  }\n  return(as.numeric(clinStay))\n}\nattach(cmh)\n",
    "created" : 1445361203785.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3613888661",
    "id" : "67C4A8B7",
    "lastKnownWriteTime" : 1445364588,
    "path" : "C:/Users/dalrymplej/Dropbox/WCCMH/R/global library.r",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}